# Documentação Técnica do Sistema de Gestão de Estacionamento

## Estrutura Geral do Projeto

* **Nome do projeto:** parking-management
* **Breve descrição do propósito:** Sistema de Gestão de Estacionamento
* **Tecnologias utilizadas:** 
  - Kotlin 2.0.21 Coroutines
  - Spring Boot 3.5.0
  - PostgreSQL 17.5

---

## Fluxo do Sistema

### Confirmação das regras de negócio implementadas:

#### Precificação dinâmica

* Implementada e funcional.

#### Lotação

* **Preparada para cenários complexos.**
* O sistema já gerencia a lotação separadamente por setor e aplica as regras de precificação dinâmica baseadas na ocupação de cada setor.

---

### Como os webhooks são tratados:

#### **ENTRY:**

1. Verifica se há alguma garagem em horário de funcionamento.
2. Caso sim, registra o evento ENTRY com o multiplicador padrão de 1.0.

**JSON recebido:**

```json
{
  "license_plate": "ZUL0001",
  "event_type": "ENTRY",
  "timestamp": "2023-10-01T10:00:00Z"
}
```

---

#### **PARKED:**

1. Verifica se o `license_plate` está registrado como ENTRY.
2. Caso sim, registra o evento PARKED com o multiplicador definido pela Regra de preço dinâmico:

    * Lotação < 25%: desconto de 10% no preço. Salva 0.9 no banco de dados.
    * Lotação <= 50%: preço base. Salva 1.0 no banco de dados.
    * Lotação <= 75%: aumento de 10% no preço. Salva 1.1 no banco de dados.
    * Lotação <= 100%: aumento de 25% no preço. Salva 1.25 no banco de dados.
    * Lotação > 100%: não é possível estacionar.
3. Caso o dia ainda não tenha um registro na tabela de receita (revenues), cria um registro para o dia com valor inicial de 0.

**JSON recebido:**

```json
{
  "license_plate": "ZUL0001",
  "lat": -23.561684,
  "lng": -46.655981,
  "event_type": "PARKED"
}
```

---

#### **EXIT:**

1. Verifica se o `license_plate` está registrado como PARKED.
2. Caso sim, calcula o valor a ser cobrado com base no multiplicador definido no evento PARKED e no tempo de permanência.
3. Registra o evento de saída e atualiza a receita (revenues) do dia correspondente no setor apropriado.

**JSON recebido:**

```json
{
  "license_plate": "ZUL0001",
  "exit_time": "2023-10-01T12:00:00.000Z",
  "event_type": "EXIT"
}
```

---

## Endpoints REST Implementados

### Controllers

Os endpoints REST foram organizados em três Controllers principais, cada um responsável por um domínio específico do sistema:

 **`VehicleRestController`**: Gerencia operações relacionadas aos veículos, como verificar status de entrada e permanência.


### **POST /plate-status**

**Request:**

```JSON
{
  "license_plate": "ZUL0001"
}
```

**Response:**

```JSON
{
  "license_plate": "ZUL0001",
  "price_until_now": 0.00,
  "entry_time": "2025-01-01T12:00:00.000Z", 
  "time_parked": "2025-01-01T12:00:00.000Z",
  "lat": -23.561684,
  "lng": -46.655981
}
```

---
**`SpotRestController`**: Gerencia informações sobre vagas de estacionamento, como disponibilidade e ocupação.

### **POST /spot-status**

**Request:**

```JSON
{
  "lat": -23.561684,
  "lng": -46.655981
}
```

**Response:**

```JSON
{
  "ocupied": false,
  "license_plate": "",
  "price_until_now": 0.00,
  "entry_time": "2025-01-01T12:00:00.000Z",
  "time_parked": "2025-01-01T12:00:00.000Z"
}
```

---
**`RevenueRestController`**: Gerencia informações sobre receitas, como cálculo e obtenção de valores acumulados por setor e dia.
### **GET /revenue**

**Request:**

```JSON
{
  "date": "2025-01-01",
  "sector": "A"
}
```

**Response:**

```JSON
{
  "amount": 0.00,
  "currency": "BRL",
  "timestamp": "2025-01-01T12:00:00.000Z"
}
```

---

## Estrutura de Dados

### Tabelas Criadas no Banco de Dados

#### **Tabela: Parking**

```sql
CREATE TABLE IF NOT EXISTS parking
(
    id                     BIGINT GENERATED BY DEFAULT AS IDENTITY,
    sector_name            VARCHAR(50)    NOT NULL,
    base_price             NUMERIC(10, 2) NOT NULL,
    max_capacity           INT            NOT NULL,
    open_hour              TIME           NOT NULL,
    close_hour             TIME           NOT NULL,
    duration_limit_minutes INT            NOT NULL,
    CONSTRAINT PK_PARKING PRIMARY KEY (id)
);

CREATE INDEX IX_PARKING_SECTOR_NAME ON parking (sector_name);
```

---

#### **Tabela: ParkingSpot**

```sql
CREATE TABLE IF NOT EXISTS parking_spots
(
    id         BIGINT GENERATED BY DEFAULT AS IDENTITY,
    parking_id BIGINT        NOT NULL REFERENCES parking (id),
    latitude   NUMERIC(9, 6) NOT NULL,
    longitude  NUMERIC(9, 6) NOT NULL,
    CONSTRAINT PK_PARKING_SPOT PRIMARY KEY (id)
);

CREATE INDEX IDX_PARKING_SPOT_PARKING_ID ON parking_spots (parking_id);
```

---

#### **Tabela: ParkingEvent**

```sql
CREATE TABLE IF NOT EXISTS parking_events
(
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY,
    license_plate   VARCHAR(20) NOT NULL,
    latitude        NUMERIC(9, 6),
    longitude       NUMERIC(9, 6),
    entry_time      TIMESTAMP   NOT NULL,
    exit_time       TIMESTAMP,
    event_type      VARCHAR(10) NOT NULL,
    price_multiplier NUMERIC(3, 2),
    amount_paid     NUMERIC(10, 2),
    CONSTRAINT PK_PARKING_EVENT PRIMARY KEY (id),
    CONSTRAINT CK_PARKING_EVENT_TYPE CHECK (event_type IN ('ENTRY', 'PARKED', 'EXIT'))
);

CREATE INDEX IDX_PARKING_EVENT_LICENSE_PLATE ON parking_events (license_plate);
CREATE INDEX IDX_PARKING_EVENT_PARKING_SPOTS_ID ON parking_spots (id);
CREATE INDEX IDX_PARKING_EVENT_EVENT_TYPE ON parking_events (event_type);
```

---

#### **Tabela: Revenue**

```sql
CREATE TABLE IF NOT EXISTS revenues
(
    id         BIGINT GENERATED BY DEFAULT AS IDENTITY,
    parking_id BIGINT         NOT NULL REFERENCES parking (id),
    date       DATE           NOT NULL,
    amount     NUMERIC(10, 2) NOT NULL,
    currency   VARCHAR(10)    NOT NULL,
    CONSTRAINT PK_REVENUE PRIMARY KEY (id)
);

CREATE INDEX IDX_REVENUE_ON_PARKING_DATE ON revenues (parking_id, date);
```

---

## Passo a Passo de Configuração e Execução

### Como rodar o projeto localmente:

1. Clone o repositório.
    ```sh
    git clone https://
    ```
2. Configure as variáveis de ambiente necessárias:
    * `SERVER_PORT=3003`
3. Execute o banco de dados PostgreSQL localmente:
   * O Spring Docker Compose está configurado no projeto, ele sobe automaticamente o container do PostgreSQL ao iniciar a aplicação. Para usá-lo o profiles active deve ser `dev`  
4. Compile e inicie o projeto.
   ```bash
   cd ~/parking-management
   ./gradlew clean build bootRun --refresh-dependencies
   ```
5. Execute o simulador com o comando:

   ```bash
   docker run -d --network="host" cfontes0estapar/garage-sim:1.0.0
   ```

---

## Limitações e Melhorias Futuras

### Limitações Identificadas:
